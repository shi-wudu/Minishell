FIRST TEST OF ALL
. and enter #most of the times have leaks in this case



QUOTES
echo "hello 'world'"
echo 'hello "world"'
echo "'"
echo '"'
echo "'""'"
echo '"'"'"'    # nested alternating quotes
echo "a'b'c"
echo 'a"b"c'
echo "'$PATH'"  # single-quoted + expansion inside
echo "''''$USER''''"
echo "$USER$PATH"
echo '$USER$PATH'
echo ">>file"

HARDER QUOTES
echo "a'b"'"c"d'
echo "abc$USER'def$HOME'ghi"
echo '"; echo HACK; #'   # test if parser leaks quotes
echo "    " | cat -e     # preserve spaces
echo """"hello""""       # empty quotes collapsing
echo "$(echo hi)"  #with bonus


REDIRECTIONS
echo hello > file1 > file2
echo hi > file1 bye bye
cat < file1 > file2
ls > file
echo test > file >> file2

REDIR FODIDAS
cat < nofile > file                                      
> out echo hi
cat < in.txt > out.txt  < other.txt #TO TEST FOR SURE
> f1 > f2 > f3 > f4 echo boom #TO TEST FOR SURE
echo > f && echo >> f && < f cat #TO TEST FOR SURE with bonus #se fizeste hard code



PIPES AND COMBINATIONS
ls | cat -e
echo hi | cat -e | grep h
echo hello | cat > file
cat < file | wc -l
echo 123 | grep 1 | wc -c
cat non_existent | grep something
ls | | cat
ls || echo fail

PIPES AND COMBINATIONS HARDER
echo a | echo b | echo c
cat | cat | cat | cat                                    ......................................... com ctrl+c / ctrl+\ so com make v
ls | grep minishell | wc -l > out
cat non_existent | grep hi | wc -c
yes | head -n 5 | cat -e
ls /no/such/dir | grep hi | cat -e
cat missing.txt | wc -l | echo done
echo one > f1 | echo two >> f1 | cat < f1 | grep two #FODIDO
echo 1 | (echo 2 | echo 3)   # should fail if no subshells #with bonys



ENVIRONMENT VARIABLES EXPANSION
echo $HOME
echo $NOT_DEFINED
echo $?
echo "$?"
echo '$?'
echo $$      # may differ depending on project rules
echo "$USER$PWD"
echo ${USER}abc   # should behave like bash (careful!)
export TEST=hello
echo $TEST
export TEST="hi there"
echo "$TEST"
$? duas vezes 

ENVIRONMENT VARIABLES EXPANSION HARDER
echo $HOME$PWD$PATH
echo "$HOME$PWD$PATH"
echo "$HOME""$PWD""$PATH"
echo $HOME"$PWD"'$PATH'
echo ${NOTSET:-fallback}
echo $SHLVL
export VAR="   spaces   "
export VAR="   spaces   " && echo $VAR #with bonus
export EMPTY= && echo $EMPTY #with bonus
unset PATH && echo $PATH && ls #with bonus



BUILTIN EDGE CASES
cd /
cd - #não és obrigado a dar handle ao cd -
cd no_such_dir
pwd
unset pwd e depois cd ..
export A=1 B=2 C
exit
exit 42
exit 9223372036854775808   # overflow case
export TEST="a b" && echo $TEST #with bonus
unset TEST && echo $TEST #with bonus
unset PATH && ls #with bonus

BUILTIN EDGE CASES HARDER
cd //////      # normalize path
cd ././././
cd ../../../../..
pwd | cat -e
export ""=abc
export ""=test
export 123=abc
export a=123 and then export a=
export 123=xyz           # invalid
exit 99999999999999999999999999999999999999   # overflow
exit abc
exit "42"
exit 42 extra_args
create a 3 folders or 4 enter them, rm -rf the first folder of it, try to go back with cd ..
unset VAR && echo $VAR #with bonus
export VAR="1=2" && export | grep VAR #with bonus
export A=B C=D E && env #with bonus
unset PATH && ls         # should fail cleanly #with bonus



HEREDOC                               
cat << EOF
>hello
>EOF

cat << "EOF"
>$USER #should not expand
>EOF

cat << 'EOF'
>$USER #also should not expand
>EOF

cat <<EOF | cat
>line1
>line2
>EOF

cat << EOF << END
>first
>EOF
>second
>END

cat <<EOF | grep hi
>hello
>hi
>EOF

cat <<EOF | cat | cat | grep two
>one
>two
>EOF

cat <<EOF
>^C during here-doc
>EOF
cat | cat | cat | sleep 3 | cat << eof | sleep 3



SIGNAL HANDLING
Ctrl+C (SIGINT) inside a here-doc
Ctrl+D at prompt
Ctrl+\ (SIGQUIT) during execution
sleep 5 then Ctrl+C
cat waiting for stdin + signals
sleep 10 → Ctrl+C
cat → Ctrl+D
cat → Ctrl+\
Check $? after each. Bash returns:
Ctrl+C → 130
Ctrl+\ → 131